#include "readmain.h"
#include <v3d_interface.h>
//#include "v3d_message.h"
#include "openSWCDialog.h"
#include <vector>
#include <iostream>
using namespace std;


bool export_list2file(QList<NeuronSWC> & newone, QString fileSaveName, QString fileOpenName)
{
    QFile file(fileSaveName);
    if (!file.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;
    QTextStream myfile(&file);
    myfile<<"# generated by Vaa3D Plugin sort_neuron_swc"<<endl;
    myfile<<"# source file(s): "<<fileOpenName<<endl;
    myfile<<"# id,type,x,y,z,r,pid"<<endl;
    for (V3DLONG i=0;i<newone.size();i++)
        myfile << newone.at(i).n <<" " << newone.at(i).type << " "<< newone.at(i).x <<" "<<newone.at(i).y << " "<< newone.at(i).z << " "<< newone.at(i).r << " " <<newone.at(i).pn << "\n";

    file.close();
    cout<<"swc file "<<fileSaveName.toStdString()<<" has been generated, size: "<<newone.size()<<endl;
    return true;
}


void readtree(V3DPluginCallback2 &callback, QWidget *parent)
{
    OpenSWCDialog * openDlg = new OpenSWCDialog(0, &callback);
    if (openDlg->exec())
    {

    NeuronTree nt = openDlg->nt;
    QList<NeuronSWC> neuron = nt.listNeuron;
    qDebug()<<neuron.size();

    QList<NeuronSWC> newone;
    NeuronSWC S;
    S.n =neuron.at(0).n;
    S.pn = neuron.at(0).pn;
    S.x = neuron.at(0).x;
    S.y = neuron.at(0).y;
    S.z = neuron.at(0).z;
    S.r = neuron.at(0).r;
    S.type = neuron.at(0).type;
    newone.append(S);
     qDebug()<<newone.size();
    cout<<"===============================welcome==============================="<<endl;
    int i=1;
    while(neuron.at(i).pn>0)
        {
            NeuronSWC S;
            S.n =neuron.at(i).n;
            S.pn = neuron.at(i).pn;
            S.x = neuron.at(i).x;
            S.y = neuron.at(i).y;
            S.z = neuron.at(i).z;
            S.r = neuron.at(i).r;
            S.type = neuron.at(i).type;
            newone.append(S);
            i=i+1;
        }
    qDebug()<<newone.size();
    QString fileOpenName = openDlg->file_name;
    QString fileDefaultName = fileOpenName+QString("_singletree.swc");
        //write new SWC to file
    QString fileSaveName = QFileDialog::getSaveFileName(0, QObject::tr("Save File"),
            fileDefaultName,
            QObject::tr("Supported file (*.swc)"
                    ";;Neuron structure	(*.swc)"
                    ));
    if (fileSaveName.isEmpty()) return;
    if (!export_list2file(newone,fileSaveName,fileOpenName))
    {
        v3d_msg("fail to write the output swc file.");
        return;
    }
    }
 }

bool downsample25(const V3DPluginArgList & input, V3DPluginArgList & output)
{
    vector<char*>* inlist = (vector<char*>*)(input.at(0).p);
    vector<char*>* outlist = NULL;
    vector<char*>* paralist = NULL;

    char * folder_path;
    QString fileSaveFolder;
    if(inlist->size() == 1)
    {
        folder_path = inlist->at(0);
    }
    else{printf("You need input a folder path.");return false; }

    if (output.size()==1)
    {
        outlist = (vector<char*>*)(output.at(0).p);
        fileSaveFolder = QString(outlist->at(0));
    }
    else {printf("You must specify one result folder.\n");return false; }

    int downsample_step = 25;

    // read files from a folder
    QStringList swcList = importFileList_addnumbersort(QString(folder_path));
    vector<NeuronTree> nt_list;
    for(V3DLONG i = 2; i < swcList.size(); i++)     // the first two are not files
    {
        QString curPathSWC = swcList.at(i);
        NeuronTree temp = readSWC_file(curPathSWC);
        nt_list.push_back(temp);
    }
    if(nt_list.size()==0) return false;

    vector<NeuronTree> nt_list2;
    vector<QList<NeuronSWC> > allthetree;
    for(int i=0; i<nt_list.size();i++)
    {
        NeuronTree m=nt_list[i];
        QList<NeuronSWC> newneuron;
        for (int j=0;j<m.listNeuron.size();j++)
        {
           NeuronSWC s;
           s.x=m.listNeuron.at(j).x / downsample_step;
           s.y=m.listNeuron.at(j).y / downsample_step;
           s.z=m.listNeuron.at(j).z / downsample_step;
           s.n=m.listNeuron.at(j).n;
           s.z=m.listNeuron.at(j).type;
           s.n=m.listNeuron.at(j).n;
           s.pn=m.listNeuron.at(j).pn;
           newneuron.append(s);
        }
        allthetree.push_back(newneuron);
    }
    // save result 2
    for(int i=0; i<nt_list2.size();i++)
    {
        QList<NeuronSWC> neuron= allthetree[i];
        QFileInfo fi = QFileInfo(swcList[i]);
        QString file_name = fi.fileName();
        QString save_name = file_name+"_25.swc";
        cout<<"file_name="<<file_name.toStdString()<<endl;
        export_neuronList2file(neuron,save_name);
    }
    return true;
}


bool export_neuronList2file(QList<NeuronSWC> & lN, QString fileSaveName)
{
    QFile file(fileSaveName);
    if (!file.open(QIODevice::WriteOnly|QIODevice::Text))
        return false;
    QTextStream myfile(&file);
    // myfile<<"# generated by Vaa3D Plugin overlap_gold"<<endl;
    myfile<<"# id,type,x,y,z,r,pid"<<endl;
    for (V3DLONG i=0;i<lN.size();i++)
        myfile << lN.at(i).n <<" " << lN.at(i).type << " "<< lN.at(i).x <<" "<<lN.at(i).y << " "<< lN.at(i).z << " "<< lN.at(i).r << " " <<lN.at(i).pn << "\n";

    file.close();
    cout<<"swc file "<<fileSaveName.toStdString()<<" has been generated, size: "<<lN.size()<<endl;
    return true;
}
QStringList importFileList_addnumbersort(const QString & curFilePath)
{
    QStringList myList;
    myList.clear();
    QStringList imgSuffix;
    imgSuffix<<"*.swc"<<"*.eswc"<<"*.SWC"<<"*.ESWC";
    QDir dir(curFilePath);
    if(!dir.exists())
    {
        cout <<"Cannot find the directory";
        return myList;
    }
    foreach(QString file, dir.entryList(imgSuffix, QDir::Files, QDir::Name)) // matching the filename to file
    {
        myList += QFileInfo(dir, file).absoluteFilePath();
    }
    foreach(QString qs, myList) qDebug() << qs;
    return myList;
}





































